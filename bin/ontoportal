#!/usr/bin/env bash

# Function to display script usage information
show_help() {
  cat << EOL
Usage:
  $0 <command> [options]
Commands:
  dev       Start the OntoPortal API development server.
  test      Run tests (all or a specific file).
  run       Run a command inside the OntoPortal API Docker container.
  help      Show this help message.

Options (dev, test, run):
  --api-url URL             Set the API URL (default: http://localhost:9393).
  --reset-cache             Remove Docker volumes (use with 'dev').
  --provision-user-only     Create only the admin user (no ontology parsing).
  --provision-ontology      Create admin user and parse ontology for use.
  --linked-data-path PATH   Path for ontologies_linked_data.
  --goo-path PATH           Path for goo.
  --sparql-client-path PATH Path for sparql-client.
  --ncbo-path PATH          Path for ncbo_cron.
EOL
}

# Function to update or create the .env file
update_env_file() {
  local api_url=${1:-http://localhost:9393}
  local linked_data_path=${2:-}
  local goo_path=${3:-}
  local sparql_client_path=${4:-}
  local ncbo_path=${5:-}

  [ -f ".env" ] || cp .env.sample .env
  file_content=$(<.env)

  while IFS= read -r line; do
    if [[ "$line" == "API_URL="* ]]; then
      echo "API_URL=$api_url"
    elif [[ "$line" == "ONTOLOGIES_LINKED_DATA_PATH="* ]]; then
      echo "ONTOLOGIES_LINKED_DATA_PATH=$linked_data_path"
    elif [[ "$line" == "GOO_PATH="* ]]; then
      echo "GOO_PATH=$goo_path"
    elif [[ "$line" == "SPARQL_CLIENT_PATH="* ]]; then
      echo "SPARQL_CLIENT_PATH=$sparql_client_path"
    elif [[ "$line" == "NCBO_PATH="* ]]; then
      echo "NCBO_PATH=$ncbo_path"
    else
      echo "$line"
    fi
  done <<< "$file_content" > .env
}

create_config_files() {
  [ -f ".env" ] || cp .env.sample .env
  [ -f "config/environments/development.rb" ] || cp config/environments/config.rb.sample config/environments/development.rb
}

build_volume_mounts_and_bash_config() {
  local linked_data_path="$1"
  local goo_path="$2"
  local sparql_client_path="$3"
  local ncbo_path="$4"

  local docker_volumes=""
  local bash_config=""

  for path_var in "linked_data_path:ontologies_linked_data" "goo_path:goo" "sparql_client_path:sparql-client" "ncbo_path:ncbo_cron" ; do
    IFS=':' read -r var_name value <<< "$path_var"
    local path_val="${!var_name}"

    if [ -n "$path_val" ]; then
      host_path="$(realpath "$path_val")"
      container_path="/srv/ontoportal/$value"
      docker_volumes+=" -v $host_path:$container_path"
      bash_config+="(git config --global --add safe.directory $container_path && bundle config local.$value $container_path) && "
    else
      bash_config+="(bundle config unset local.$value) && "
    fi
  done

  export COMMON_DOCKER_VOLUMES="$docker_volumes"
  export COMMON_BASH_CONFIG="$bash_config"
}

run_container_with_shared_setup() {
  local container_name="$1"
  local service_name="$2"
  local custom_command="$3"
  local linked_data_path="$4"
  local goo_path="$5"
  local sparql_client_path="$6"
  local detached="$7" 
  
  # Remove existing container to avoid name collisions
  if docker ps -a --format "{{.Names}}" | grep -q "^${container_name}$"; then
    echo "Stopping and removing existing container '$container_name'..."
    docker stop "$container_name" 2>/dev/null || true
    docker rm "$container_name" 2>/dev/null || true
  fi
  
  build_volume_mounts_and_bash_config "$linked_data_path" "$goo_path" "$sparql_client_path" ""

  local full_bash_cmd="${COMMON_BASH_CONFIG} (bundle check || bundle install || bundle update) && $custom_command"
  
  # Construction of the command with --rm for ephemerality
  local docker_run_cmd="docker compose --profile vo -p ontoportal_docker run --rm --name $container_name"
  
  if [ "$detached" == "true" ]; then
    docker_run_cmd+=" -d"
  else
    docker_run_cmd+=" -it"
  fi

  docker_run_cmd+=" $COMMON_DOCKER_VOLUMES --service-ports $service_name bash -c \"$full_bash_cmd\""

  echo "[+] Executing: $docker_run_cmd"
  eval "$docker_run_cmd"
}

run_cron_docker_cmd() {
  local cmd="$1"
  local docker_cmd="docker compose -f docker-compose.yml -p ontoportal_docker run --remove-orphans --rm --name cron-service --service-ports ncbo_cron bash -c \"$cmd\""
  if ! eval "$docker_cmd"; then
    echo "[-] Error: Failed to run provisioning: $cmd"
    exit 1
  fi
}

provision_user() {
  echo "[+] Running Cron provisioning user"
  source .env
  local commands=(
    "bundle exec rake user:create[admin,admin@nodomain.org,admin]"
    "bundle exec rake user:adminify[admin]"
    "bundle exec rake user:create['ontoportal_ui','ontoportal_ui@nodomain.org']"
    "bundle exec rake user:apikey:reset['ontoportal_ui','1de0a270-29c5-4dda-b043-7c3580628cd5']"
  )
  for cmd in "${commands[@]}"; do
    run_cron_docker_cmd "$cmd"
  done
}

provision_ontology() {
  echo "[+] Running Cron provisioning with ontology"
  source .env
  docker compose -p ontoportal_docker down --volumes >/dev/null 2>&1
  provision_user
  local commands=(
    "bundle exec bin/ncbo_ontology_import --admin-user admin --ontologies $STARTER_ONTOLOGY --from-apikey $OP_API_KEY --from $OP_API_URL"
    "bundle exec bin/ncbo_ontology_process -o $STARTER_ONTOLOGY"
  )
  for cmd in "${commands[@]}"; do
    run_cron_docker_cmd "$cmd"
  done
}

run_command() {
  local custom_command_api_arg="$1"
  local reset_cache=false
  local api_url=""
  local linked_data_path=""
  local goo_path=""
  local sparql_client_path=""
  local ncbo_path=""
  local provision_user_only_arg=""
  local provision_ontology_arg=""

  shift
  while [[ "$#" -gt 0 ]]; do
    case $1 in
      --reset-cache) reset_cache=true; shift ;;
      --api-url) api_url="$2"; shift 2 ;;
      --linked-data-path) linked_data_path="$2"; shift 2 ;;
      --goo-path) goo_path="$2"; shift 2 ;;
      --sparql-client-path) sparql_client_path="$2"; shift 2 ;;
      --ncbo-path) ncbo_path="$2"; shift 2 ;;
      --provision-user-only) provision_user_only_arg="$1"; shift 1 ;;
      --provision-ontology) provision_ontology_arg="$1"; shift 1 ;;
      *) echo "[-] Unknown option: $1"; show_help; exit 1 ;;
    esac
  done

  # --- Cleanup Trap Implementation ---
  cleanup() {
    echo -e "\n[+] Shutting down background services..."
    # Stop sidekiq. Because we used --rm earlier, it will be removed automatically.
    docker stop sidekiq >/dev/null 2>&1 || true
    echo "[+] Done."
  }
  # Trap SIGINT (Ctrl+C), SIGTERM (Kill), and EXIT (Normal script end)
  trap cleanup SIGINT SIGTERM EXIT
  # -----------------------------------

  if [ "$reset_cache" = true ]; then
    docker compose -p ontoportal_docker down --volumes
  fi

  update_env_file "$api_url" "$linked_data_path" "$goo_path" "$sparql_client_path" "$ncbo_path"
  source .env

  if [ "$provision_ontology_arg" == "--provision-ontology"  ]; then
    provision_ontology
  elif [ "$provision_user_only_arg" == "--provision-user-only"  ]; then
    provision_user
  fi

  local cmd_api=${custom_command_api_arg:-"bundle exec shotgun --host 0.0.0.0 --env=development --port 9393"}
  local cmd_sidekiq="bundle exec sidekiq -C ./config/sidekiq.yml -r /srv/ontoportal/ontologies_api/app.rb --env=development"
  
  # Run sidekiq in detached mode
  run_container_with_shared_setup "sidekiq" "sidekiq" "$cmd_sidekiq" "$ONTOLOGIES_LINKED_DATA_PATH" "$GOO_PATH" "$SPARQL_CLIENT_PATH" true
  
  # Run API in foreground
  echo "[+] Server running at $API_URL"
  run_container_with_shared_setup "api-service" "api" "$cmd_api" "$ONTOLOGIES_LINKED_DATA_PATH" "$GOO_PATH" "$SPARQL_CLIENT_PATH" false
}

dev() {
  local server_cmd=${1:-shotgun}
  shift || true
  local cmd=""
  case "$server_cmd" in
    shotgun) cmd="bundle exec shotgun --host 0.0.0.0 --env=development --port 9393" ;;
    rackup) cmd="bundle exec rackup --host 0.0.0.0 --env=development --port 9393" ;;
    *) echo "[-] Invalid server: $server_cmd"; exit 1 ;;
  esac
  run_command "$cmd" "$@"
}

test() {
  local test_path=""
  local test_options=""
  local all_arguments=()
  local backend="vo"

  while [ "$#" -gt 0 ]; do
    case "$1" in
      --backend) backend="$2"; shift 2 ;;
      --api-url|--linked-data-path|--goo-path|--sparql-client-path) all_arguments+=("$1" "$2"); shift 2 ;;
      --reset-cache) all_arguments+=("$1"); shift 1 ;;
      *) if [ -z "$test_path" ]; then test_path="$1"; else test_options="$test_options $1"; fi; shift ;;
    esac
  done

  local cmd=""
  if [ "$test_path" = "all" ]; then
    cmd="bundle exec rake test test:docker:$backend"
  else
    cmd="bundle exec rake test test:docker:$backend TEST='$test_path' TESTOPTS='$test_options'"
  fi
  run_command "$cmd" "${all_arguments[@]}"
}

run() {
  docker compose run --rm -it api bash -c "$*"
}

create_config_files

case "$1" in
  "run") run "${@:2}" ;;
  "dev") dev "${@:2}" ;;
  "test") test "${@:2}" ;;
  "help") show_help ;;
  *) show_help; exit 1 ;;
esac